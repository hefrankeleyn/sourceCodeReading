# druid1.2.8源码阅读_02

[toc]

## 一、问题

我在想如果我要开发一个数据源连接池，我会怎么做。简单的JDBC要经历如下步骤：

- 第一步：加载数据库驱动；
- 第二步：建立数据库连接；
- 第三步：通过Statement执行SQL；
- 第四步：从RestSet中获取返回结果；

## 二、当`new DruidDataSource()`时，在执行什么

调用父类`DruidAbstractDataSource`的构造函数

首先，初始化参数

```java
// 默认参数
// 默认自定提交打开
protected volatile boolean defaultAutoCommit = true;
// 初始化大小为0
protected volatile int initialSize  = DEFAULT_INITIAL_SIZE;
// 最大活跃数位0
protected volatile int maxActive = DEFAULT_MAX_ACTIVE_SIZE;
// 最小空闲连接数 0
protected volatile int minIdle = DEFAULT_MIN_IDLE;
// 最大空闲连接数 8
protected volatile int maxIdle = DEFAULT_MAX_IDLE;
// 最大等待毫秒数：-1，无限长。超过这个时间就报错
protected volatile long maxWait = DEFAULT_MAX_WAIT;
// 拿链接失败重试的次数
protected int notFullTimeoutRetryCount = 0;
// 用于验证的查询语句：默认为null
protected volatile String validationQuery = DEFAULT_VALIDATION_QUERY;
// 验证语句查询超时时间：默认无限长
protected volatile int validationQueryTimeout = -1;
// 从连接池获取申请链接时，连接池判断这连接是否是可用的。默认为false
protected volatile boolean testOnBorrow = DEFAULT_TEST_ON_BORROW;
// 使用完连接，连接池回收的时候判断该连接是否可用。默认为false
protected volatile boolean testOnReturn = DEFAULT_TEST_ON_RETURN;
// 从连接池申请连接时，如果testOnBorrow=false，验证是否为空闲连接，如果是验证连接是否可用。默认为false
protected volatile boolean testWhileIdle = DEFAULT_WHILE_IDLE;
// 是否缓存游标，对支持游标的数据库性能提升巨大。默认为false
protected volatile boolean poolPreparedStatements = false;
// 
protected volatile boolean sharePreparedStatements = false;


```



```java
// 默认创建一个 非公平的锁： 不保证先来的线程先得到锁
protected ReentrantLock lock = new ReentrantLock(lockFair);
```



